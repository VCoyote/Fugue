package controller;

import java.util.Random;
import java.util.TreeMap;

import notes.Chord;
import notes.scales.Key;
import notes.types.ChordFunction;

public class ChordGenerator {
	
	/**
	 * The random number generator to use
	 */
	private static final Random randomizer = new Random();
	
	/**
	 * Generates a random chord off of a tonic chord.
	 * 
	 * @param beatsUntilLastMeasure
	 * 			How many beats there are until the last measure, not including
	 * 			this one
	 * @param currentKey
	 * 			This song's current key
	 * @return A random chord
	 */
	public static Chord generateChordOffTonic(int beatsUntilLastMeasure,
			Key currentKey) {
		TreeMap<Double, ChordFunction> chordFunctions = new TreeMap<>();
		
		// If there are two beats until the last measure, you don't want to
		// awkwardly sit on tonic.
		if (beatsUntilLastMeasure == 2) {
			// 50% chance of subdominant
			chordFunctions.put(.5, ChordFunction.SUBDOMINANT);
			// 50% chance of dominant
			chordFunctions.put(1.0, ChordFunction.DOMINANT);
		} else {
			// 15% chance of tonic
			chordFunctions.put(.15, ChordFunction.TONIC);
			// 55% chance of subdominant
			chordFunctions.put(.7, ChordFunction.SUBDOMINANT);
			// 20% chance of a secondary dominant
			chordFunctions.put(.9, ChordFunction.SECONDARY_DOMINANT);
			// 10% chance of dominant
			chordFunctions.put(1.0, ChordFunction.DOMINANT);
		}
		
		return pickAChord(currentKey, chordFunctions);
	}
	
	/**
	 * Generates a random chord based off a subdominant chord.
	 * 
	 * @param beatsUntilLastMeasure
	 * 			How many beats there are until the last measure, not including
	 * 			this one
	 * @param currentKey
	 * 			This song's current key
	 * @return A random chord
	 */
	public static Chord generateChordOffSubdominant(int beatsUntilLastMeasure,
			Key currentKey) {
		TreeMap<Double, ChordFunction> chordFunctions = new TreeMap<>();
		
		// If the next beat starts the last measure, resolve the half-cadence.
		if (beatsUntilLastMeasure == 0) {
			// 100% chance of dominant
			chordFunctions.put(1.0, ChordFunction.DOMINANT);
		} else {
			// 55% chance of subdominant
			chordFunctions.put(.55, ChordFunction.SUBDOMINANT);
			// 25% chance of secondary dominant
			chordFunctions.put(.8, ChordFunction.SECONDARY_DOMINANT);
			// 20% chance of dominant
			chordFunctions.put(1.0, ChordFunction.DOMINANT);
		}
		
		return pickAChord(currentKey, chordFunctions);
	}
	
	/**
	 * Generate a chord off the secondary dominant. (Hint: It leads straight
	 * to the chord it's dominant to.)
	 * 
	 * @param prevChord
	 * 			The previous chord
	 * @return The chord it leads to
	 */
	public static Chord generateChordOffSecondaryDominant(Chord prevChord) {
		return prevChord.leadsTo();
	}
	
	/**
	 * Generates a random chord based off a dominant chord.
	 * 
	 * @param beatsUntilLastMeasure
	 * 			How many beats there are until the last measure, not including
	 * 			this one
	 * @param currentKey
	 * 			This song's current key
	 * @return A random chord
	 */
	public static Chord generateChordOffDominant(int beatsUntilLastMeasure,
			Key currentKey) {
		TreeMap<Double, ChordFunction> chordFunctions = new TreeMap<>();
		
		// If there is one beat until the last measure, you don't want to
		// awkwardly sit on tonic.
		if (beatsUntilLastMeasure == 1) {
			// Always return dominant to set up for a cadence.
			chordFunctions.put(1.0, ChordFunction.DOMINANT);
			
		// If the next beat is the last measure, resolve the cadence.
		} if (beatsUntilLastMeasure == 0) {
			// Resolve the cadence.
			chordFunctions.put(1.0, ChordFunction.RESOLUTION);
			
		// Otherwise, proceed as normal.
		} else {
			// 20% chance of dominant
			chordFunctions.put(.2, ChordFunction.DOMINANT);
			// 10% chance of tonic
			chordFunctions.put(1.0, ChordFunction.TONIC);
		}
		
		return pickAChord(currentKey, chordFunctions);
		
	}
	
	/**
	 * Given a TreeMap generated by another function, pick a chord.
	 * 
	 * @param currentKey
	 * 			The current key of the song
	 * @param chordFunctions
	 * 			The TreeMap of weighted ChordFunctions to choose from
	 * @return A random chord from a random ChordFunction
	 */
	private static Chord pickAChord(Key currentKey,
			TreeMap<Double, ChordFunction> chordFunctions) {
		// Use the TreeMap to pick a random ChordFunction
		Double probability = randomizer.nextDouble();
		ChordFunction chordFunction
				= chordFunctions.higherEntry(probability).getValue();
		
		// Choose randomly from the available chords
		Chord[] chords = currentKey.getChords(chordFunction);
		int chordChoice = randomizer.nextInt(chords.length);
		return chords[chordChoice];
	}
}
